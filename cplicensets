#!/usr/local/cpanel/3rdparty/bin/perl
# Copyright 2019, cPanel, L.L.C.
# All rights reserved.
# http://cpanel.net
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the owner nor the names of its contributors may be
# used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# SCRIPT: cplicensets
# PURPOSE: Run some tests to determine what may be causing a cPanel license failure.
# AUTHOR: Peter Elsner <peter.elsner@cpanel.net>
# CURRENT MAINTAINER: Peter Elsner <peter.elsner@cpanel.net>

my $version = "2.0.16";
our $maxGCE = 7;

use strict;
use Socket;
use IO::Socket::INET;
use IO::Socket::SSL;
use Time::HiRes qw( clock_gettime CLOCK_REALTIME );
use Sys::Hostname;
use Getopt::Long;
use Term::ANSIColor qw(:constants);
use Cpanel::Config::LoadWwwAcctConf ();
use Cpanel::Validate::Hostname;
use Cpanel::Validate::IP;
use Cpanel::Config::LoadUserOwners ();
use NetAddr::IP;
use Text::CSV;
use Data::Dump::Streamer;
use Cpanel::Usage ();
use DateTime;
our $L3=0;
$Term::ANSIColor::AUTORESET = 1;
$|                          = 1;

_init_run_state();
if ( exists $ENV{'PACHA_AUTOFIXER'} ) {
    _set_run_type('cptech');
}
elsif ( defined $ENV{'HISTFILE'} and index( $ENV{'HISTFILE'}, 'cpanel_ticket' ) != -1 ) {
    _set_run_type('cptech');
}
else {
    foreach ( @ENV{ 'SSH_CLIENT', 'SSH_CONNECTION' } ) {
        next unless defined $_;

        #next unless m{\A 208\.74\.12[0-7]}xms;
        next unless m{\A (184\.94\.197\.[2-6]|208\.74\.123\.98)}xms;
        _set_run_type('cptech');
        last;
    }
}
my ( $skipdate, $withlogs, $verifypage, $verbose, $help );
our @WARNINGS;
our @HISTORY;
our $histCnt;
our $external_ip_address;
our $external_ip_address_2089;
our %license;
our $buffer;
our $HOSTNAME;
our $RUN_STATE;
our $Trial      = 0;
our $host       = 'verify.cpanel.net';
our $helper_url = "https://" . $host;
our $cgls       = 0;
our $timenow    = time();
our $isGCE_IP;
our $isAWS_IP;
our $isSoloNum    = 0;
our $isDevelLic   = 0;
our $isOneTimeLic = 0;
our $sendtomsg    = "";

module_sanity_check();
get_external_ip();

GetOptions(
    "skipdate"   => \$skipdate,
    "verbose"    => \$verbose,
    "verifypage" => \$verifypage,
    "withlogs"   => \$withlogs,
    "help"       => \$help,
);

our $cPLiscFile = '/usr/local/cpanel/cpanel.lisc';
our $DEVinConf;
our $envtype;

print "<c>\n";
print MAGENTA "cPanel License Troubleshooter - Version: $version\n";
if ($verifypage) {
    getVerifyJSON();
    print "</c>\n";
    exit;
}
if ($withlogs) {
    read_last_50_lines_of_license_log();
    print "</c>\n";
    exit;
}
Usage() if ($help);

check_for_centOS5();
print BOLD MAGENTA "--help show usage information\n";
print BOLD MAGENTA "--verbose show everything [Default: show warnings only].\n\n";
verify_license();
loadHistory();
my $LicenseActive    = is_active();
my $LicensedProducts = LicensedProducts();
my $validFQDN        = is_hostname_fqdn();

print_working( "Servers External IP Address Detected As: " . CYAN $external_ip_address );
if ($LicenseActive) {
    print_working( "License Status: " . CYAN $LicenseActive . GREEN " [ " . $helper_url . " ]" );
    print_working( "License Valid For: " . CYAN $LicensedProducts )
      unless ( !$LicensedProducts );
}
else {
    print_working( "License Status: " . RED "License not found on verify.cpanel.net, or request timed out." . GREEN "\n\t\\_ Check manually at " . $helper_url );
    print_working( "License Valid For: " . RED "COULD NOT DETERMINE!" );
    push( @WARNINGS, "Could not verify license status via $helper_url" );
    push(
        @WARNINGS,
        "Could not determine the services/products this license covers"
    );
}

check_for_GCE();
check_for_AWS();
chk_for_cloud_ready();
check_for_solo();
if ($isDevelLic) {
    print BOLD YELLOW "[INFO] - This is a development license.\n";
}
if ($isOneTimeLic) {
    print BOLD YELLOW "[INFO] - This is a One-Time license.\n";
}
print_working( "Hostname is FQDN: " . $validFQDN . CYAN " [$HOSTNAME]" );
check_for_accountinglog();
get_envtype();

# END OF INFORMATIONAL!  - Start checks and only display if verbose or warning/errors are found.

check_for_lisc_lock();
check_for_trial();
check_hostsfile();
get_mainip();
get_ipinfo($external_ip_address);
get_wwwacctconf_ip();
get_logStats();
check_for_multiple_defroute();
get_devices();
run_check_valid_server_hostname();
check_kernel_hostname();
display_etc_hostname();
get_network_hostname();
get_ip_of_hostname();
check_file_for_odd_chars("/etc/hosts");
check_file_for_odd_chars("/etc/sysconfig/network");
check_if_hostname_resolves_locally();
check_resolvconf();
check_for_cloudcfg();
check_for_dhclient_exit_hook();
shenanigans();
check_for_license_error();
get_hostname_at_install();
check_for_hostname_changes();
check_for_cpkeyclt_from_cli();
get_date();
check_crons();
check_for_cpnat();
check_routing();
check_root_servers();
check_auth_cpanel_resolution();
check_iptables();
check_other_ports();
check_cpanel_lisc_file();
run_rdate();
chkCreds();
display_route();
get_cpsrvd_restarts();
get_last_reboots();
getVerifyDATA();

my $warnmess;
my $warncnt = @WARNINGS;
if ( $warncnt > 0 ) {
    print "\n";
    print YELLOW "Found $warncnt warnings:\n";
    foreach $warnmess (@WARNINGS) {
        chomp($warnmess);
        print RED "\t\\_ $warnmess\n";
    }
}
print "</c>\n";
exit;

sub check_for_centOS5 {
    my $sysinfo_config = '/var/cpanel/sysinfo.config';
    return if !-f $sysinfo_config;
    my $rpm_dist_ver;
    open my $fh, '<', $sysinfo_config or return;
    while (<$fh>) {
        if (/^rpm_dist_ver=(\d+)$/) {
            $rpm_dist_ver = $1;
            last;
        }
    }
    close $fh or return;
    return if !$rpm_dist_ver;
    return if ( $rpm_dist_ver > 5 );
    print_warn("Sorry, this cannot run on your version of OS!");
    print "</c>\n";
    exit;
}

sub module_sanity_check {
    my @required_mods = qw( IO::Socket::PortState IO::Interface::Simple );
    my $reqmod;
    if ($verbose) {
        print_working("\nChecking if required Perl Modules are installed:");
    }
    foreach $reqmod (@required_mods) {
        eval("use $reqmod");
        if ($@) {
            print_warn( "\t \\_ " . $reqmod . " No - Installing!" )
              unless ( !$verbose );
            my $modinstall = qx[ /usr/local/cpanel/bin/cpanm $reqmod 2> /dev/null ];
        }
        else {
            print_OK( "\t \\_ " . $reqmod . " OK!\n" ) unless ( !$verbose );
        }
    }
}

sub get_external_ip {
    $external_ip_address      = qx[ curl -s -m 3 https://myip.cpanel.net/v1.0/ ];
    $external_ip_address_2089 = qx[ curl -s -m 3 http://myip.cpanel.net:2089/v1.0/ ];
    chomp($external_ip_address);
    chomp($external_ip_address_2089);
    if ( $external_ip_address ne $external_ip_address_2089 ) {
        push(
            @WARNINGS,
            "External IP Address [$external_ip_address] on port 80 does not match that on port 2089 [$external_ip_address_2089]"
        );
    }
}

sub print_working {
    my $text = shift;
    print BOLD YELLOW ON_BLACK . $text . "\n";
}

sub print_warn {
    my $text = shift;
    print BOLD RED ON_BLACK . $text . "\n";
}

sub print_OK {
    my $text = shift;
    print BOLD GREEN ON_BLACK . $text;
}

sub system_formatted {
    open( my $cmd, "-|", "$_[0]" );
    while (<$cmd>) {
        print_formatted("$_");
    }
    close $cmd;
}

sub print_formatted {
    my @input = split /\n/, $_[0];
    foreach (@input) { print CYAN "    $_\n"; }
}

sub verify_license {
    my $url = '/app/verify?ip=' . $external_ip_address;
    $helper_url .= $url;
    my $sock = IO::Socket::SSL->new(
        PeerAddr => $host,
        PeerPort => 443,
        Proto    => 'tcp',
        Timeout  => 5
    );
    local $SIG{'ALRM'} = sub { return (); };
    alarm 5;
    print $sock "GET ${url} HTTP/1.1\r\nHost: ${host}\r\n\r\n";
    read $sock, $buffer, 20_000;
    alarm 0;
    close $sock;
}

sub LicensedProducts {
    if ( $buffer =~ /alt="cPanel\/WHM"/ ) {
        $license{'cpanel'} = "cPanel";
    }

    if ( $buffer =~ /alt="CloudLinux"/ ) {
        $license{'cloudlinux'} = "CloudLinux";
    }

    if ( $buffer =~ /alt="DNSONLY"/ ) {
        $license{'dnsonly'} = "DNSOnly";
    }

    if ( $buffer =~ /alt="KernelCare"/ ) {
        $license{'kernelcare'} = "KernelCare";
    }

    if ( $buffer =~ /alt="Imunify360"/ ) {
        $license{'imunify360'} = "Imunify360";
    }

    if ( $buffer =~ /alt="LiteSpeed"/ ) {
        $license{'litespeed'} = "LiteSpeed";
    }

    if ( $buffer =~ /ONE TIME FEE/ ) {
        $isOneTimeLic = 1;
    }

    if ( $buffer =~ /MONTHLY-CPANEL-SOLO/ ) {
        $isSoloNum = 1;
    }

    if ( $buffer =~ /DEVELOPMENT/ ) {
        $isDevelLic = 1;
    }

    if ( my $licenses = join " ", map { "[$license{$_}]" } sort keys %license ) {
        return $licenses;
    }
}

sub is_active {
    if ( $buffer =~ m/active<br\/>/ ) {
        if ( $buffer =~ m/15-DAY-TEST<\/td>/ ) {
            $Trial = 1;
        }
        return "Active";
    }
    if ( $buffer =~ /expired on<br\/>/ ) {
		if ($L3) { 
        	$sendtomsg = CYAN "Please send to L3";
		}
		else { 
        	$sendtomsg = CYAN "Please send to Customer Service";
		}
        return "Expired - " . $sendtomsg;
    }
}

sub is_hostname_fqdn {
    $HOSTNAME = qx[ hostname -f ];
    chomp($HOSTNAME);
    if ( $HOSTNAME !~ /([\w-]+)\.([\w-]+)\.(\w+)/ ) {
        push( @WARNINGS, "Hostname [ $HOSTNAME ] may not be a valid FQDN\n\t\t\\_ SEE: https://en.wikipedia.org/wiki/Fully_qualified_domain_name" );
        return BOLD RED "No";
    }
    else {
        return GREEN "Yes";
    }
}

sub check_for_lisc_lock {
    return if ( !( -e ("/usr/local/cpanel/lisc.lock") ) );
    push( @WARNINGS, "The /usr/local/cpanel/lisc.lock file present!" );
}

sub check_for_trial {
    return unless ( -e ("/var/cpanel/trial") );
    if ($Trial) {
        print YELLOW "[INFO] - Trial touchfile  detected - If you just purchased a license a hard restart of cpsrvd may be required before cpkeyclt will work!\n";
    }
    else {
        push(
            @WARNINGS,
            "The /var/cpanel/trial touchfile found and license is not a trial license"
        ) unless ($Trial);
    }
}

sub check_hostsfile {
    print_working("Checking /etc/hosts for $HOSTNAME") unless ( !$verbose );
    my $hostsfile = qx[ grep $HOSTNAME /etc/hosts ];
    if ( substr( $hostsfile, 0, 1 ) eq "#" ) {
        push(
            @WARNINGS,
            "The $HOSTNAME appears to be commented out in the /etc/hosts file."
        );
        return;
    }
    if ($hostsfile) {
        if ($verbose) {
            print BOLD GREEN "\t\\_ $HOSTNAME was found in the /etc/hosts file\n";
            print BOLD CYAN "\t\t\\_ $hostsfile";
        }
    }
    else {
        push(
            @WARNINGS,
            "The $HOSTNAME was not found in the /etc/hosts file."
        );
    }
}

sub check_for_accountinglog {
    print_working("Checking accounting.log file for first created account");
    if ( -e ("/var/cpanel/accounting.log") ) {
        my $FirstAcct     = qx[ grep ':CREATE:' /var/cpanel/accounting.log | head -1 ];
        my $FirstAcctEnd  = index( $FirstAcct, ":CREATE:", 0 );
        my $FirstAcctDate = substr( $FirstAcct, 0, $FirstAcctEnd - 0 );
        print BOLD CYAN "\t\\_ First account created on: " . YELLOW $FirstAcctDate . "\n";
    }
    else {
        print BOLD CYAN "\t\\_ None - Possible new install\n";
    }
}

sub get_envtype {
    return if ( !-e ("/var/cpanel/envtype") );
    $envtype = qx[ cat /var/cpanel/envtype ];
    if ( !$envtype ) {
        $envtype = "Unknown";
        push( @WARNINGS, "Unknown envtype for this server" );
    }
    print_working("This server's environment (envtype) is: $envtype");
}

sub get_mainip {
    print_working("Obtaining contents of /var/cpanel/mainip:")
      unless ( !$verbose );
    my $mainip = qx[ cat /var/cpanel/mainip ];
    chomp($mainip);
    if ($mainip) {
        print_OK( "\t\\_ " . $mainip . "\n" ) unless ( !$verbose );
        my $isOnServer = qx[ ip addr show | grep $mainip ];
        chomp($isOnServer);
        if ( !($isOnServer) ) {
            print RED " [WARN] /var/cpanel/mainip [$mainip] is not bound to this server.\n";
            print YELLOW "\t \\_ Might be fixed by running /usr/local/cpanel/scripts/mainipcheck";
            push(
                @WARNINGS,
                "/var/cpanel/mainip [$mainip] not bound to this server.\n\t \\_ Might be fixed by running /usr/local/cpanel/scripts/mainipcheck"
            );
        }
    }
    else {
        push(
            @WARNINGS,
            "The mainip in /var/cpanel/mainip [$mainip] seems to be missing"
        );
    }
}

sub get_ipinfo {
    return unless ($verbose);
    my $ipinfoIP = $_[0];
    my $ipinfoline;
    print_working("Getting ipinfo for $ipinfoIP");
    my @IPINFO = qx[ curl -s ipinfo.io/$ipinfoIP ];
    foreach $ipinfoline (@IPINFO) {
        chomp($ipinfoline);
        if ( $ipinfoline =~ m/{|}/ ) {
            next;
        }
        $ipinfoline =~ s/\"//g;
        $ipinfoline =~ s/,$//g;
        print BOLD CYAN "\t\\_$ipinfoline\n";
    }
}

sub get_wwwacctconf_ip {
    my $conf = Cpanel::Config::LoadWwwAcctConf::loadwwwacctconf();
    $DEVinConf = $conf->{'ETHDEV'};
    my $wwwacctIP = $conf->{'ADDR'};
    return unless ($verbose);
    print_working( "Obtaining ADDR from /etc/wwwacct.conf file: " . CYAN $wwwacctIP);
}

sub get_logStats {
    return unless ($verbose);
    my $rootOwnedCnt  = qx[ grep -c 'confirm this connection was from a root owned process' /usr/local/cpanel/logs/license_log ];
    my $expireCnt     = qx[ grep -c '^The license is expired' /usr/local/cpanel/logs/license_log ];
    my $activeCnt     = qx[ grep -c '^The license has been activated too many times' /usr/local/cpanel/logs/license_log ];
    my $failureCnt    = qx[ grep -c 'License update failed' /usr/local/cpanel/logs/license_log ];
    my $successCnt    = qx[ grep -c 'License update succeeded' /usr/local/cpanel/logs/license_log ];
    my $trialCnt      = qx[ grep -c 'Already Used cPanel/WHM Trial License for this IP' /usr/local/cpanel/logs/license_log ];
    my $TotTWRestarts = qx[ grep -c 'Restarting cpsrvd' /var/log/chkservd.log ];
    chomp($rootOwnedCnt);
    chomp($expireCnt);
    chomp($activeCnt);
    chomp($failureCnt);
    chomp($successCnt);
    chomp($trialCnt);
    chomp($TotTWRestarts);
    print_working("Obtaining stats from license_log file:");
    print BOLD CYAN "\t\\_ Total number of times license shows expired in license_log: " . MAGENTA $expireCnt . "\n";
    print BOLD CYAN "\t\\_ Total number of times license shows been activated too many times in license_log: " . MAGENTA $activeCnt . "\n";
    print BOLD CYAN "\t\\_ Total number of times license update shows failed in license_log: " . MAGENTA $failureCnt . "\n";
    print BOLD CYAN "\t\\_ Total number of times license update shows succeeded in license_log: " . MAGENTA $successCnt . "\n";
    print BOLD CYAN "\t\\_ Total number of times license update shows Already had a Trial License in license_log: " . MAGENTA $trialCnt . "\n";
    print BOLD CYAN "\t\\_ Total number of times license could not confirm it was from a root owned process in license_log: " . MAGENTA $rootOwnedCnt . "\n";
    print BOLD CYAN "\t\\_ Total number of times chkservd has restarted cpsrvd: " . MAGENTA $TotTWRestarts . "\n";
    return;
}

sub get_devices {
    my ( $device, $deviceline, $nicIP );
    print_working("Obtaining NIC Devices:") unless ( !$verbose );
    my @DEVICES = qx[ ip -o link show ];
    my $inConf  = 0;
    foreach $deviceline (@DEVICES) {
        chomp($deviceline);
        next if ( $deviceline =~ /DOWN/ );
        ($device) = ( split( /\s+/, $deviceline ) )[1];
        chop($device);    ## Remove trailing colon
        if ( $device eq "lo" ) { next; }
        if ( $device eq "venet0" ) { $device = "venet0:0"; }
        if ( -e ("/etc/sysconfig/network-scripts/ifcfg-$device") ) {
            my $if = IO::Interface::Simple->new($device);
            $nicIP = $if->address;
            print BOLD MAGENTA ON_BLACK . "\t \\_ Ethernet Device Name: " . CYAN $device . "\n"
              unless ( !$verbose );
            print BOLD YELLOW . "\t\t \\_ Address: " . CYAN $nicIP . "\n"
              unless ( !$verbose );
            my $MACVendor = getMAC( $if->hwaddr );
            print BOLD YELLOW . "\t\t \\_ MAC: " . CYAN $if->hwaddr . " [" . $MACVendor . "]\n"
              unless ( !$verbose );
            print BOLD YELLOW . "\t\t \\_ Broadcast: " . CYAN $if->broadcast . "\n"
              unless ( !$verbose );
            print BOLD YELLOW . "\t\t \\_ Netmask: " . CYAN $if->netmask . "\n"
              unless ( !$verbose );
            print BOLD YELLOW . "\t\t \\_ MTU: " . CYAN $if->mtu . "\n"
              unless ( !$verbose );
            arping_check( $device, $nicIP );

            if ( $device eq "eth0" and $nicIP eq "" ) {
                push(
                    @WARNINGS,
                    "Device eth0 has no address - Seeing Waiting for devices to settle errors in license_log?"
                );
            }
            if ( $device eq $DEVinConf ) {
                $inConf = 1;
            }
            check_for_dhcp($device);
        }
    }
    if ( !$inConf or $DEVinConf eq "" ) {
        push(
            @WARNINGS,
            RED "ETHDEV in /etc/wwwacct.conf (" . WHITE $DEVinConf . RED ") missing or undefined (blank) as an active device!\n\t\t \\_ Should be set to " . CYAN . $device
        );
    }
    my $ETHDEVcnt = qx[ grep -c ETHDEV /etc/wwwacct.conf ];
    if ( $ETHDEVcnt > 1 ) {
        push(
            @WARNINGS,
            RED "Multiple ETHDEV lines found in /etc/wwwacct.conf!"
        );
    }
}

sub arping_check {
    my $nicdevice = $_[0];
    my $nicIPAddr = $_[1];
    return if ( $envtype =~ m/virtuozzo|vzcontainer/ );
    return if ( $nicIPAddr eq "" or $nicdevice eq "" );
    my $ARPINGCMD = "";
    $ARPINGCMD = qx[ arping -D -I $nicdevice -c 2 $nicIPAddr | grep 'Received 0' ];
    chomp($ARPINGCMD);
    if ( $ARPINGCMD =~ m/Received 0/ ) {
        print_working( "Checking $nicdevice for multiple devices responding to $nicIPAddr: " . GREEN . "None" )
          unless ( !$verbose );
    }
    else {
        push(
            @WARNINGS,
            "The IP address $nicIPAddr may be listening on other devices! ($ARPINGCMD)"
        );
    }
}

sub check_for_multiple_defroute {
    print_working("Checking for multiple DEFROUTE=yes lines:") unless ( !$verbose );
    opendir( NETSCRIPTS, "/etc/sysconfig/network-scripts/" );
    my @defroutes = readdir(NETSCRIPTS);
    close(NETSCRIPTS);
    my $NetScriptFile;
    my $defroutecnt  = 0;
    my $defrouteline = "[ ";
    foreach $NetScriptFile (@defroutes) {
        chomp($NetScriptFile);
        next unless ( $NetScriptFile =~ m/ifcfg-/ );
        my $DFCnt = qx[ grep '^DEFROUTE=yes' /etc/sysconfig/network-scripts/$NetScriptFile ];
        if ($DFCnt) {
            $defroutecnt++;
            $defrouteline .= $NetScriptFile . " ";
        }

    }
    if ( $defroutecnt > 1 ) {
        print RED . "\t \\_ Found " . WHITE $defroutecnt . " " . CYAN $defrouteline . "]" unless ( !$verbose );
        push(
            @WARNINGS,
            "Found multiple DEFROUTE=yes lines within the /etc/sysconfig/network-scripts/ifcfg-* files.\n\t\t \\_ Only the main NIC device should have a DEFROUTE defined. [$defrouteline]"
        );
    }
    else {
        print BOLD GREEN . "\t \\_ None" unless ( !$verbose );
    }
    print "\n" unless ( !$verbose );
}

sub check_for_dhcp {
    my $nicdevice = $_[0];
    print_working("Checking Networking Configs For DHCP:") unless ( !$verbose );
    my $grep4dhcp = qx[ grep -i 'dhcp' /etc/sysconfig/network-scripts/ifcfg-$nicdevice ];
    my $Look4NM   = qx[ ps faux | grep 'NetworkManager' | grep -v grep ];
    if ($grep4dhcp) {
        print RED "\t\\_ NIC Device " . $nicdevice . " set for DHCP.\n"
          unless ( !$verbose );
        push(
            @WARNINGS,
            "NIC Device " . $nicdevice . " has DHCP config. May cause automatic IP/Hostname changes."
        );
    }
    if ($Look4NM) {
        print RED "\t\\_ NetworkManager process found.\n"
          unless ( !$verbose );
        push(
            @WARNINGS,
            "Found NetworkManager processes running. May cause automatic IP/Hostname changes.\n\t\t\\_ [ See: https://documentation.cpanel.net/display/CKB/How+to+Disable+Network+Manager ]"
        );
    }
    if ( !$grep4dhcp and !$Look4NM ) {
        print BOLD GREEN "\t \\_ None Found\n" unless ( !$verbose );
    }
}

sub getMAC {
    my $macaddr        = $_[0];
    my $macaddrencoded = url_encode($macaddr);
    my $MACchkURL      = "https://cpaneltech.ninja/cgi-bin/getvendor.cgi";
    my $result         = qx[ curl -s "$MACchkURL?$macaddr" ];
    chomp($result);
    $result =~ s/\s+$//;
    return $result;
}

sub url_encode {
    my $rv = shift;
    $rv =~ s/([^a-z\d\Q.-_~ \E])/sprintf("%%%2.2X", ord($1))/geix;
    $rv =~ tr/ /+/;
    return $rv;
}

sub run_check_valid_server_hostname {
    my $HostnameValid = Cpanel::Validate::Hostname::is_valid($HOSTNAME);
    if ($HostnameValid) {
        print_working( "Checking For Valid Server Hostname: " . GREEN "OK" )
          unless ( !$verbose );
    }
    else {
        push(
            @WARNINGS,
            "The " . $HOSTNAME . " does not appear to be a valid hostname!"
        );
    }
    my ($FirstHost) = ( split( /\./, $HOSTNAME ) )[0];
    my $FirstHostWarn = "";
    if ( $FirstHost =~ m/^whm$|^cpanel$|^webmail$|^webdisk$|^mail$|^autodiscover$/ ) {
        $FirstHostWarn = RED "$HOSTNAME should not begin with a service subdomain ($FirstHost)\n\t\t \\_ See: " . CYAN "https://documentation.cpanel.net/display/80Docs/Change+Hostname";
        push( @WARNINGS, $FirstHostWarn );
    }
}

sub check_kernel_hostname {
    my $KERN_HOSTNAME = qx [ sysctl kernel.hostname | cut -d = -f2 2> /dev/null ];
    $KERN_HOSTNAME = alltrim($KERN_HOSTNAME);
    if ( $KERN_HOSTNAME eq $HOSTNAME ) {
        print_working( "Verifying if sysctl kernel.hostname matches " . $HOSTNAME . ": " . GREEN "OK" )
          unless ( !$verbose );
    }
    else {
        push(
            @WARNINGS,
            "The value in sysctl kernel.hostname does not match $HOSTNAME"
        );
    }
}

sub alltrim() {
    my $string2trim = $_[0];
    $string2trim =~ s/^\s*(.*?)\s*$/$1/;
    return $string2trim;
}

sub display_etc_hostname {
    return if ( !( -e ("/etc/hostname") ) );
    my $etchostname = qx[ cat /etc/hostname ];
    chomp($etchostname);
    print_working("Checking for an /etc/hostname file: Present - Contents are:")
      unless ( !$verbose );
    print BOLD GREEN "\t\\_ " . $etchostname . "\n" unless ( !$verbose );
    if ( $etchostname ne $HOSTNAME ) {
        push(
            @WARNINGS,
            "Value in /etc/hostname [$etchostname] does not match servers hostname [$HOSTNAME]"
        );
    }
}

sub get_network_hostname {
    return if ( !( -e ("/etc/sysconfig/network") ) );
    my $networkhost = qx[ grep '^HOSTNAME=' /etc/sysconfig/network ];
    chomp($networkhost);
    if ($networkhost) {
        print_working("Obtaining the HOSTNAME setting from /etc/sysconfig/network: Present - Contents are:") unless ( !$verbose );
        print BOLD GREEN "\t\\_ " . $networkhost . "\n" unless ( !$verbose );
    }
    ($networkhost) = ( split( /=/, $networkhost ) )[1];
    $networkhost =~ s/\"//g;
    if ( $networkhost ne $HOSTNAME ) {
        push(
            @WARNINGS,
            "HOSTNAME value in /etc/sysconfig/network [$networkhost] does not match servers hostname [$HOSTNAME]"
        );
    }
}

sub get_ip_of_hostname {
    my $HOSTNAME_IP = qx[ dig +tries=2 +time=5 \@208.67.222.222 $HOSTNAME +short | head -1 2>/dev/null ];
    chomp($HOSTNAME_IP);
    my $IPValid = Cpanel::Validate::IP::is_valid_ipv4($HOSTNAME_IP);
    if ( !$IPValid ) {
        push( @WARNINGS, "Could not reverse $HOSTNAME to a valid IP address." );
    }
    if ( $HOSTNAME_IP eq $external_ip_address ) {
        print_working("IP for $HOSTNAME [$HOSTNAME_IP] matches servers IP [$external_ip_address]") unless ( !$verbose );
    }
    else {
        push(
            @WARNINGS,
            "IP address for $HOSTNAME [$HOSTNAME_IP] does not match servers IP [$external_ip_address]"
        );
    }
    if ($HOSTNAME_IP) {
        my $REVERSED_IP = qx[ dig +tries=2 +time=5 \@208.67.220.220 -x $HOSTNAME_IP +short 2>/dev/null ];
        chomp($REVERSED_IP);
        chop($REVERSED_IP);
        if ($REVERSED_IP) {
            print_working( "Reversing IP [$HOSTNAME_IP]: " . GREEN $REVERSED_IP)
              unless ( !$verbose );
            if ( $REVERSED_IP ne $HOSTNAME ) {
                push(
                    @WARNINGS,
                    "Reverse of $HOSTNAME_IP [$REVERSED_IP] does not match $HOSTNAME"
                );
            }
        }
        else {
            push(
                @WARNINGS,
                "Failed to reverse $HOSTNAME_IP back to $HOSTNAME"
            );
        }
    }
}

sub check_if_hostname_resolves_locally {
    my $LOCAL_HOSTNAME_IP = qx[ dig \@$external_ip_address +tries=2 +time=5 $HOSTNAME +short | head -1 2>/dev/null ];
    chomp($LOCAL_HOSTNAME_IP);
    print_working("Checking if $HOSTNAME resolves locally")
      unless ( !$verbose );
    my $IPValid = Cpanel::Validate::IP::is_valid_ipv4($LOCAL_HOSTNAME_IP);
    if ( !$IPValid ) {
        push( @WARNINGS, "Could not resolve $HOSTNAME locally" );
        print RED "\t \\_ No\n" unless ( !$verbose );
        return;
    }
    else {
        if ($verbose) {
            print BOLD GREEN "\t \\_ Yes [$LOCAL_HOSTNAME_IP]\n"
              unless ( !$verbose );
        }
        print_working("Checking if $LOCAL_HOSTNAME_IP reverses back to $HOSTNAME: ")
          unless ( !$verbose );
        my $LOCAL_HOSTNAME_REVERSED = qx[ dig +tries=2 +time=5 -x $LOCAL_HOSTNAME_IP +short 2>/dev/null ];
        chomp($LOCAL_HOSTNAME_REVERSED);
        chop($LOCAL_HOSTNAME_REVERSED);
        if ( $LOCAL_HOSTNAME_REVERSED eq $HOSTNAME ) {
            print BOLD GREEN "\t \\_ Yes\n" unless ( !$verbose );
        }
        else {
            print RED "\t \\_ No\n" unless ( !$verbose );
            push(
                @WARNINGS,
                "$LOCAL_HOSTNAME_IP does not reverse back to $HOSTNAME"
            );
        }
    }
}

sub check_file_for_odd_chars {
    my $TheFile = $_[0];
    return if !-e $TheFile;
    my ( $line, @invalid, $invalid );
    print_working("Checking $TheFile for non-ascii characters:")
      unless ( !$verbose );
    open( HOSTS, $TheFile );
    my @DATA = <HOSTS>;
    close(HOSTS);
    my @invalid = undef;
    my $cnt     = 0;

    foreach $line (@DATA) {
        chomp($line);
        if ( $line =~ /[^!-~\s]/g ) {
            push( @invalid, "$line contains => [ $& ]" );
        }
    }
    splice( @invalid, 0, 1 );
    $cnt = @invalid;
    if ( $cnt > 0 ) {
        push(
            @WARNINGS,
            "The $TheFile file has $cnt line(s) containing non-ascii characters - use --verbose to view."
        );
        if ($verbose) {
            foreach $invalid (@invalid) {
                chomp($invalid);
                print MAGENTA "\t\\_ $invalid\n";
            }
        }
    }
    else {
        print_OK("\t\\_ All Good\n") unless ( !$verbose );
    }
}

sub check_resolvconf {
    my $grep4NM = qx[ grep 'Generated by NetworkManager' /etc/resolv.conf ];
    if ($grep4NM) {
        push(
            @WARNINGS,
            "/etc/resolv.conf was possibly Generated by NetworkManager - may cause resolution issues!"
        );
    }
    my $grep4invalidNS = qx[ grep 'nameserver 127.0.0.' /etc/resolv.conf ];
    if ($grep4invalidNS) {
        push(
            @WARNINGS,
            "/etc/resolv.conf has invalid nameserver value - may cause resolution issues!"
        );
    }
    if ( !$grep4NM and !$grep4invalidNS and $verbose ) {
        print_working("Checking /etc/resolv.conf for anomalies: ");
        print BOLD GREEN "\t\\_ Looks Good!\n";
    }
}

sub check_for_cloudcfg {
    return if ( !( -e ("/etc/cloud") ) );
    if ( -e ("/etc/cloud/cloud.cfg.d/99-preserve-hostname.cfg") ) {
        if ($verbose) {
            print_working( "/etc/cloud/cloud.cfg.d/99-preserve-hostname.cfg " . GREEN "is present" );
        }
    }
    my $preserve_hostname = qx[ grep -srl 'preserve_hostname: true' /etc/cloud/* ];
    my $manageetchosts    = qx[ grep -srl 'manage_etc_hosts: false' /etc/cloud/* ];
    if ($preserve_hostname) {
        print BOLD GREEN "\t\\_ preserve_hostname is set to true in $preserve_hostname"
          unless ( !$verbose );
    }
    else {
        push(
            @WARNINGS,
            "preserve_hostname not set within any file in /etc/cloud/cloud.cfg.d/"
        );
    }
    if ($manageetchosts) {
        print BOLD GREEN "\t\\_ manage_etc_hosts is set to false in $manageetchosts"
          unless ( !$verbose );
    }
    else {
        push(
            @WARNINGS,
            "manage_etc_hosts not set within any file in /etc/cloud/cloud.cfg.d/"
        );
    }
}

sub check_for_dhclient_exit_hook {
    return if ( !( -e ("/etc/dhcp/dhclient-exit-hooks.d/") ) );
    print_working("Checking for /etc/dhcp/dhclient-exit-hooks.d/ scripts")
      unless ( !$verbose );
    my $zzzsethostname = 0;
    my $sethostname    = 0;
    if ( -e ("/etc/dhcp/dhclient-exit-hooks.d/zzz-set-hostname.sh") ) {
        print BOLD GREEN "\t\\_ zzz-set-hostname.sh is present\n"
          unless ( !$verbose );
        $zzzsethostname = 1;
    }
    else {
        print RED "\t\\_ zzz-set-hostname.sh not present\n"
          unless ( !$verbose );
    }
    if ( -e ("/etc/dhcp/dhclient-exit-hooks.d/set-hostname.sh") ) {
        print BOLD GREEN "\t\\_ set-hostname.sh is present\n"
          unless ( !$verbose );
        $sethostname = 1;
    }
    else {
        print RED "\t\\_ set-hostname.sh not present\n"
          unless ( !$verbose );
    }
    if ($isGCE_IP) {
        push(
            @WARNINGS,
            "IP belongs to Google and is a Google Compute Engine (GCE)"
        );
        if ( !$sethostname and !$zzzsethostname ) {
            push(
                @WARNINGS,
                "Neither zzz-set-hostname.sh nor set-hostname.sh script was found - See: https://go.cpanel.net/cloudhostname"
            );
        }
        if ($sethostname) {
            my $dhcpEHfile = qx[ grep $HOSTNAME /etc/dhcp/dhclient-exit-hooks.d/set-hostname.sh ];
            if ( !$dhcpEHfile ) {
                push( @WARNINGS, "The /etc/dhcp/dhclient-exit-hooks.d/set-hostname.sh file does not contain $HOSTNAME" );
            }
        }
        if ($zzzsethostname) {
            my $dhcpEHfile = qx[ grep $HOSTNAME /etc/dhcp/dhclient-exit-hooks.d/zzz-set-hostname.sh ];
            if ( !$dhcpEHfile ) {
                push( @WARNINGS, "The /etc/dhcp/dhclient-exit-hooks.d/zzz-set-hostname.sh file does not contain $HOSTNAME" );
            }
        }
    }
    if ( -e ("/etc/dhcp/dhclient.d/google_hostname.sh") ) {
        push(
            @WARNINGS,
            "Found /etc/dhcp/dhclient.d/google_hostname.sh file - consider disabling this. Causes license issues!"
        );
    }
}

sub getGCE_IPs {
    my $chkIP = $_[0];
    chomp($chkIP);
    my $startGCE = 1;
    my $GCEsubnet;
    my @GCEsubnets;
    my @GCE;
    my $gceline;
    while ( $startGCE <= $maxGCE ) {
        @GCEsubnets = qx[ dig txt _cloud-netblocks$startGCE.googleusercontent.com +short | tr " " "\n" | grep ip4 | cut -f 2 -d : ];
        foreach $gceline (@GCEsubnets) {
            chomp($gceline);
            push( @GCE, $gceline );
        }
        $startGCE++;
    }
    $gceline = "";
    foreach $gceline (@GCE) {
        chomp($gceline);
        my $network = NetAddr::IP->new($gceline);
        my $ip      = NetAddr::IP->new($chkIP);
        if ( $ip->within($network) ) {
            return 1;
        }
    }
}

sub getAWS_IPs {
    my $chkIP = $_[0];
    chomp($chkIP);
    my $AWSsubnet;
    my $awsline;
    my $junk;
    my $AWSrange;
    my @AWSsubnets;
    my @AWS;
    @AWSsubnets = qx [ curl -s https://ip-ranges.amazonaws.com/ip-ranges.json | grep 'ip_prefix' | cut -f2 -d : ];

    foreach $awsline (@AWSsubnets) {
        $awsline =~ s/\"//g;
        $awsline =~ s/,//g;
        $awsline =~ s/\s+//g;
        $AWSrange = $awsline;
        chomp($AWSrange);
        push( @AWS, $AWSrange );
    }
    $awsline - "";
    foreach $awsline (@AWS) {
        chomp($awsline);
        my $network = NetAddr::IP->new($awsline);
        my $ip      = NetAddr::IP->new($chkIP);
        if ( $ip->within($network) ) {
            return 1;
        }
    }
}

sub check_for_license_error {
    return unless ( -e ("/usr/local/cpanel/logs/license_error.display") );
    print_working("Found a license error: ") unless ( !$verbose );
    open( LICERR, "/usr/local/cpanel/logs/license_error.display" );
    my @LICERR = <LICERR>;
    my $errline;
    close(LICERR);
    my $toomany = 0;
    foreach $errline (@LICERR) {
        chomp($errline);
        print RED "\t\\_ $errline\n" unless ( !$verbose );
        if ( $errline =~ m/activated too many times on different machines/ ) {
            my $CSA = CSA();
            if ($CSA) {
				if ($L3) { 
                	$sendtomsg = CYAN "Please send to L3"; 
				}
				else { 
                	$sendtomsg = CYAN "Please send to Customer Service"; 
				}
                push(
                    @WARNINGS,
                    "This license has been activated too many times - " . $sendtomsg
                ) unless ( !iam('cptech') );
            }
            else {
                $sendtomsg = CYAN "Please send to L3";
                push(
                    @WARNINGS,
                    "This license has been activated too many times - " . $sendtomsg
                ) unless ( !iam('cptech') );
            }
            $toomany = 1;
        }
    }
    if ( $toomany == 0 ) {
        push(
            @WARNINGS,
            "The /usr/local/cpanel/logs/license_error.display file contains additional license errors. "
        );
    }
}

sub get_hostname_at_install {
    return if !-e "/var/log/cpanel-install.log";
    return unless ($verbose);
    print_working("Hostname at time of cPanel install was set to: ");
    my $HOSTNAME_AT_INSTALL = qx[ grep 'Validating that the system hostname' /var/log/cpanel-install.log | cut -d \" \" -f12 | cut -d \"\'\" -f2 2> /dev/null ];
    chomp($HOSTNAME_AT_INSTALL);
    if ( !($HOSTNAME_AT_INSTALL) ) {
        print BOLD CYAN "\t\\_ Unknown\n";
    }
    else {
        print BOLD CYAN "\t\\_ " . $HOSTNAME_AT_INSTALL . "\n";
    }
}

sub check_for_hostname_changes {
    return unless ($verbose);
    print_working("Checking access_log for hostname changes:");
    my (
        $allhostnames,    $histline,              @HOSTNAME_CHANGES, $histchange,
        $hostname_change, $hostname_date_change1, $hostname_date_change2
    );
    my @accesslog_hostnames = qx[ grep 'dochangehostname?hostname' /usr/local/cpanel/logs/access_log ];
    my $alhostcnt           = @accesslog_hostnames;
    if ( $alhostcnt == 0 ) {
        print GREEN "\t \\_ None\n";
    }
    else {
        foreach $allhostnames (@accesslog_hostnames) {
            chomp($allhostnames);
            ($hostname_change) = ( split( /\s+/, $allhostnames ) )[6];
            ( $hostname_date_change1, $hostname_date_change2 ) =
              ( split( /\s+/, $allhostnames ) )[ 3, 4 ];
            ($hostname_change) = ( split( /=/, $hostname_change ) )[1];
            if ($hostname_change) {
                print BOLD CYAN "\t\\_ Changed to: " . $hostname_change . " on " . $hostname_date_change1 . " " . $hostname_date_change2 . "\n"
                  unless ( $hostname_change eq "1" );
            }
        }
    }
    print_working("Checking /root/.bash_history for hostname changes:");
    my @hostchangeHist;
    my $histtime;
    if ( $histCnt == 0 ) {
        print GREEN "\t \\_ None\n";
    }
    else {
        foreach $histline (@HISTORY) {
            chomp($histline);
            if ( substr( $histline, 0, 1 ) eq "#" ) {
                $histtime = substr( $histline, 1 );
            }
            if ( $histline =~ m/\/usr\/local\/cpanel\/bin\/set_hostname |hostnamectl set-hostname |hostname / ) {
                print BOLD CYAN "\t \\_ On " . scalar localtime($histtime) . " - " . $histline . "\n"
                  unless ( $histline =~ m/grep|vim \/etc\/hostname|vi \/etc\/hostname|rm|\-f/ );
            }
        }
    }
    print_working("Checking /var/log/messages for hostname changes:");
    my $messhost;
    my @messlogRestarts = qx[ grep 'systemd-hostnamed: Changed host name to' /var/log/messages ];
    my $messcnt         = @messlogRestarts;
    if ( $messcnt == 0 ) {
        print BOLD GREEN "\t \\_ None\n";
    }
    else {
        foreach $messhost (@messlogRestarts) {
            chomp($messhost);
            print BOLD CYAN "\t\\_ On: $messhost\n";
        }
    }
}

sub check_for_cpkeyclt_from_cli {
    return if ( !$verbose );
    my $histline;
    print_working("Checking /root/.bash_history for cpkeyclt:");
    my @cpkeycltINHist;
    my $histtime;
    foreach $histline (@HISTORY) {
        chomp($histline);
        if ( substr( $histline, 0, 1 ) eq "#" ) {
            $histtime = substr( $histline, 1 );
        }
        if ( $histline =~ m/cpkeyclt|run_cpkeyclt/ ) {
            push(
                @cpkeycltINHist,
                "\t\\_ On " . BOLD GREEN scalar localtime($histtime) . " - " . $histline
            );
        }
    }
    my $cpkeyInHistLine;
    if (@cpkeycltINHist) {
        foreach $cpkeyInHistLine (@cpkeycltINHist) {
            chomp($cpkeyInHistLine);
            print "$cpkeyInHistLine\n";
        }
    }
    else {
        print BOLD CYAN "\t\\_ None\n";
    }
    print_working("Displaying last 20 cpkeyclt calls from license_log: ");
    my @Last20cpkeyclt = qx[ grep 'License Update Request' /usr/local/cpanel/logs/license_log | tail -20 ];
    my $Last20;
    foreach $Last20 (@Last20cpkeyclt) {
        chomp($Last20);
        print BOLD CYAN "\t\\_ " . $Last20 . "\n";
    }
}

sub loadHistory {
    return if ( !( -e "/root/.bash_history" ) );
    open( HISTORY, "/root/.bash_history" );
    @HISTORY = <HISTORY>;
    close(HISTORY);
    $histCnt = @HISTORY;
}

sub shenanigans {
    getHist();
    chk_mounts();
    chk_etc_hosts();
    chk_fwdip();
    chk_etc_ips();
    chk_cgls();
    chk_cgls2();
    chk_cgls3();
    chk_rclocal();
    proxy_chk();
}

sub chk_fwdip {
    return if ( !( -e ("/var/cpanel/domainfwdip") ) );
    my ( $fwdip, @FWDIP );
    open( FWDIP, "/var/cpanel/domainfwdip" );
    @FWDIP = <FWDIP>;
    close(FWDIP);
    foreach $fwdip (@FWDIP) {
        chomp($fwdip);
        if ( $fwdip =~ m/208.74./ ) {
            $sendtomsg = CYAN "Please send to L3";
            $L3=1;
            push(
                @WARNINGS,
                "Found $fwdip in /var/cpanel/domainfwdip file - " . $sendtomsg
            ) unless ( !iam('cptech') );
        }
    }
}

sub getHist {
    my ( $histline, $histtime, $lookfor );
    my @lookfor = qw( cpanel.lisc lic.bigconfig.com cpsanitycheck.so sectools 3jenan secinstall update_cpanelv2 license.onlinelic.net ./s.sh tsocks yoncu.com );
    foreach $histline (@HISTORY) {
        chomp($histline);
        if ( substr( $histline, 0, 1 ) eq "#" ) {
            $histtime = substr( $histline, 1 );
            next;
        }
        foreach $lookfor (@lookfor) {
            if ( $lookfor eq $histline ) {
                $sendtomsg = CYAN "Please send to L3";
                $L3=1;
                push(
                    @WARNINGS,
                    "Found $histline in /root/.bash_history [" . scalar localtime($histtime) . "] CPANEL-22182 - " . $sendtomsg
                ) unless ( $histline =~ m/grep/ or !iam('cptech') );
            }
        }
    }
}

sub chk_etc_hosts {
    open( HOSTS, "/etc/hosts" );
    my @HOSTS = <HOSTS>;
    close(HOSTS);
    my $hostline;
    foreach $hostline (@HOSTS) {
        chomp($hostline);
        if ( $hostline =~ m/auth.cpanel.net|auth2.cpanel.net|auth3.cpanel.net|dev.cpanel.net/ ) {
            $sendtomsg = CYAN "Please send to L3";
            $L3=1;
            push(
                @WARNINGS,
                "Found $hostline in /etc/hosts - " . $sendtomsg
            ) unless ( !iam('cptech') );
        }
    }
}

sub chk_mounts {
    my $liscMounted = qx[ mount | grep 'lisc' ];
    return unless ($liscMounted);
    $sendtomsg = CYAN "Please send to L3";
    $L3=1;
    push( @WARNINGS, "cpanel.lisc possibly mounted - " . $sendtomsg ) unless ( !iam('cptech') );
}

sub chk_etc_ips {
    my $ourIPinetcips = qx[ grep '208.74.' /etc/ips ];
    return unless ($ourIPinetcips);
    $sendtomsg = CYAN "Please send to L3";
    $L3=1;
    push(
        @WARNINGS,
        "Found cPanel IP's within /etc/ips file - " . $sendtomsg
    ) unless ( !iam('cptech') );
}

sub chk_cgls {
    my @dirs = qw( /usr/local/cgls /usr/bin/update_soft /usr/local/src/Lisans.php /usr/bin/chattrx /usr/local/cpanel/cpkeyclt.yedek /tmp/fkcplisc/verify/cpv.c );
    for my $dir (@dirs) {
        next if !-e $dir;
        $sendtomsg = CYAN "Please send to L3";
        $L3=1;
        push( @WARNINGS, "Found " . $dir . " " . $sendtomsg . " [CPANEL-22182]" ) unless ( !iam('cptech') or $cgls );
        $cgls = 1;
    }
}

sub chk_cgls2 {
    my $isASCII = qx[ file /usr/local/cpanel/cpkeyclt | grep 'ASCII' ];
    return unless ($isASCII);
    $sendtomsg = CYAN "Please send to L3";
    $L3=1;
    push( @WARNINGS, $sendtomsg . " [CPANEL-22182]" ) unless ( !iam('cptech') or $cgls );
    $cgls = 1;
}

sub chk_rclocal {
    return unless ( -e "/etc/rc.local" );
    my $rcLocal = qx[ grep cpkeyclt /etc/rc.local ];
    return unless ($rcLocal);
    $sendtomsg = CYAN "Please send to L3";
    $L3=1;
    push( @WARNINGS, "Detected cpkeyclt in /etc/rc.local [CPANEL-22182] - " . $sendtomsg ) unless ( !iam('cptech') );
}

sub chk_cgls3 {
    if ( -e ("/etc/cron.d/cspcrons") ) {
        $sendtomsg = CYAN "Please send to L3";
        $L3=1;
        push( @WARNINGS, "Found cspcrons " . $sendtomsg . " [CPANEL-22182]" ) unless ( !iam('cptech') or $cgls );
        $cgls = 1;
    }
    if ( -e ("/etc/cron.d/cgls") ) {
        $sendtomsg = CYAN "Please send to L3";
        $L3=1;
        push( @WARNINGS, "Found cgls " . $sendtomsg . " [CPANEL-22182]" ) unless ( !iam('cptech') or $cgls );
        $cgls = 1;
    }
    if ( -e ("/etc/cron.d/CSPcPanel") ) {
        $sendtomsg = CYAN "Please send to L3";
        $L3=1;
        push( @WARNINGS, "Found CSPcPanel " . $sendtomsg . " [CPANEL-22182]" ) unless ( !iam('cptech') or $cgls );
        $cgls = 1;
    }
    if ( -e ("/opt/cpanel/csp") ) {
        $sendtomsg = CYAN "Please send to L3";
        $L3=1;
        push( @WARNINGS, "Found csp " . $sendtomsg . " [CPANEL-22182]" ) unless ( !iam('cptech') or $cgls );
        $cgls = 1;
    }
}

sub check_crons {
    print_working("Checking for cpkeyclt in cron related files")
      unless ( !$verbose );
    my ( $ExistsInCronLog, $ExistsInCron, $CronPositive );
    my $cronservice = "";
    if ( -e ("/usr/bin/systemctl") ) {
        $cronservice = qx[ systemctl status crond.service | grep 'active' ];
        chomp($cronservice);
    }
    if ( $cronservice and !-e ("/var/log/cron") ) {
        $ExistsInCronLog = qx[ /usr/bin/journalctl | grep -i cron | grep cpkeyclt ];
        chomp($ExistsInCronLog);
        if ($ExistsInCronLog) {
            print RED "\t\\_ Found cpkeyclt in systemd cron [journalctl]\n"
              unless ( !$verbose );
            push( @WARNINGS, "Found cpkeyclt in cron log file [journalctl]" );
            $CronPositive = 1;
        }
    }
    elsif ( -e ("/var/log/cron") ) {
        $ExistsInCronLog = qx[ grep 'cpkeyclt' /var/log/cron ];
        chomp($ExistsInCronLog);
        if ($ExistsInCronLog) {
            print RED "\t\\_ Found cpkeyclt in /var/log/cron\n"
              unless ( !$verbose );
            push( @WARNINGS, "Found cpkeyclt in cron log file" );
            $CronPositive = 1;
        }
    }
    else {
        print RED "\t\\_ No /var/log/cron file found and systemd crond.service not configured!\n"
          unless ( !$verbose );
        push(
            @WARNINGS,
            "No /var/log/cron file found and systemd cron.service not configured!"
        );
        $CronPositive = 1;
    }
    $ExistsInCron = qx[ grep 'cpkeyclt' /var/spool/cron/* ];
    chomp($ExistsInCron);
    if ($ExistsInCron) {
        print RED "\t\\_ cpkeyclt found in /var/spool/cron/ file \n\t\t \\_ [ $ExistsInCron ]\n"
          unless ( !$verbose );
        push(
            @WARNINGS,
            "cpkeyclt found in /var/spool/cron/ file \n\t\t \\_ [ $ExistsInCron ]"
        );
        $CronPositive = 1;
    }
    $ExistsInCron = qx[ grep -srl 'cpkeyclt' /etc/cron.* ];
    chomp($ExistsInCron);
    if ($ExistsInCron) {
        print RED "\t\\_ cpkeyclt found in one of the /etc/cron.* directories \n\t\t \\_ [ $ExistsInCron ]\n"
          unless ( !$verbose );
        push(
            @WARNINGS,
            "cpkeyclt found in one of the /etc/cron.* directories \n\t\t \\_ [ $ExistsInCron ]"
        );
        $CronPositive = 1;
    }
    $ExistsInCron = qx[ grep 'cpkeyclt' /etc/crontab ];
    chomp($ExistsInCron);
    if ($ExistsInCron) {
        print RED "\t\\_ cpkeyclt found in /etc/crontab\n" unless ( !$verbose );
        push( @WARNINGS, "cpkeyclt found in some /etc/crontab" );
        $CronPositive = 1;
    }
    if ( !$CronPositive ) {
        print BOLD GREEN "\t \\_ None\n" unless ( !$verbose );
    }
}

sub check_for_cpnat {
    print_working("Checking for existence of cpnat file (1:1 NAT)")
      unless ( !$verbose );
    if ( -e ("/var/cpanel/cpnat") ) {
        open( CPNAT, "/var/cpanel/cpnat" );
        my @CPNAT = <CPNAT>;
        close(CPNAT);
        my $cpnatline = "";
        print BOLD GREEN "\t\\_ Found one - contents are:\n"
          unless ( !$verbose );
        foreach $cpnatline (@CPNAT) {
            chomp($cpnatline);
            print BOLD CYAN "\t\t\\_ " . $cpnatline . "\n" unless ( !$verbose );
            my ( $publicIP, $privateIP ) = ( split( /\s+/, $cpnatline ) );
            chomp($publicIP);
            chomp($privateIP);
            if ( $publicIP eq $privateIP ) {
                push(
                    @WARNINGS,
                    "cpnat file found but all publicly routeable addresses are the same as the local address - Not a NAT system"
                );
            }
        }
    }
    else {
        print BOLD GREEN "\t\\_ None\n" unless ( !$verbose );
    }
}

sub check_root_servers {
    print_working("Checking if this server can resolve ROOT servers:")
      unless ( !$verbose );
    my @ROOT      = qw( a b c d e f g h i j k l m );
    my $ROOT_HOST = ".root-servers.net";
    my $rootserver;
    foreach $rootserver (@ROOT) {
        $rootserver = $rootserver . $ROOT_HOST;
        my $GOOD = qx[ dig +tries=2 +time=5 $rootserver +short 2> /dev/null ];
        if ($GOOD) {
            print_OK("\t \\_ $rootserver - Good!\n") unless ( !$verbose );
        }
        else {
            print_warn("\t \\_ $rootserver - Failed!") unless ( !$verbose );
            push( @WARNINGS, "Failed to resolve $rootserver" );
        }
    }
}

sub check_routing {
    return if ( !$verbose );
    print_working("Displaying IP routing info (if any)");
    my @ROUTINGINFO = qx[ ip addr | grep 'inet ' 2> /dev/null ];
    my $routeline;
    foreach $routeline (@ROUTINGINFO) {
        chomp($routeline);
        my ($internal1) = ( split( /\s+/, $routeline ) )[2];
        my ($internal)  = ( split( /\//,  $internal1 ) )[0];
        if ( $internal eq "127.0.0.1" ) { next; }
        print BOLD MAGENTA ON_BLACK . "\t \\_ Internal: " . CYAN $internal;
        my $external = qx[ wget -O - -q --tries=1 --timeout=2 --bind-address=$internal http://myip.cpanel.net/v1.0/ 2> /dev/null ];
        if ($external) {
            chomp($external);
            print BOLD MAGENTA ON_BLACK " / External: " . CYAN $external . "\n";
        }
        else {
            print RED " / No Reply!\n";
        }
    }
}

sub check_auth_cpanel_resolution {
    print_working("Checking to see if auth.cpanel.net can resolve: ")
      unless ( !$verbose );
    my $authline;
    my @AUTH_RESOLUTION = qx[ dig +tries=2 +time=5 auth.cpanel.net +short 2>/dev/null ];
    my $cnt             = @AUTH_RESOLUTION;
    if ( $cnt == 0 ) {
        print RED "\t\\_ Failed!\n" unless ( !$verbose );
        push(
            @WARNINGS,
            "This server cannot reach or resolve auth.cpanel.net"
        );
    }
    else {
        foreach $authline (@AUTH_RESOLUTION) {
            chomp($authline);
            print BOLD GREEN "\t\\_ " . $authline . "\n" unless ( !$verbose );
        }
    }
}

sub check_iptables {
    print_working("Checking if cPanel IP's (208.74.x.x) are blocked")
      unless ( !$verbose );
    my $IPTABLES_CHK = qx[ iptables -L -n | grep '^208.74.' | grep DROP ];
    if ($IPTABLES_CHK) {
        print RED "\t\\_ cPanel IP's may be blocked via IPTABLES\n"
          unless ( !$verbose );
        push( @WARNINGS, "cPanel IP's may be blocked via IPTABLES" );
    }
    else {
        print BOLD GREEN "\t\\_ Looks good!\n" unless ( !$verbose );
    }
    my $DROPPORTCHK = qx[ iptables -L -n | egrep '2083|2082|2095|20962086|2087' | grep DROP ];
    if ($DROPPORTCHK) {
        print RED "\t\\_ Some cPanel ports may be blocked via IPTABLES\n"
          unless ( !$verbose );
        push(
            @WARNINGS,
            "cPanel ports may be blocked via IPTABLES Can cause cpsrvd to restart too often!"
        );
    }
}

sub check_other_ports {
    print_working("Checking firewall (if license ports can access auth.cpanel.net)")
      unless ( !$verbose );
    eval("use IO::Socket::PortState qw( check_ports )");
    my %port_hash = (
        tcp => {
            2089 => {},
            80   => {},
            110  => {},
            143  => {},
            25   => {},
            23   => {},
            993  => {},
            995  => {},
        }
    );
    my $timeout = 5;
    my $host    = 'auth.cpanel.net';
    chomp($host);
    my $host_hr = check_ports( $host, $timeout, \%port_hash );
    for my $port ( sort { $a <=> $b } keys %{ $host_hr->{tcp} } ) {
        my $yesno = $host_hr->{tcp}{$port}{open} ? GREEN "OK" : RED "Failed!";
        chomp($yesno);
        if ( $yesno =~ m/Failed!/ ) {
            push(
                @WARNINGS,
                "Could not reach port $port on auth.cpanel.net from this server -- connections may be throttled."
            );
        }
        print_OK( "\t \\_ " . $port . " - " . $yesno . "\n" )
          unless ( !$verbose );
    }
}

sub check_cpanel_lisc_file {
    if ( !-e ("$cPLiscFile") ) {
        push( @WARNINGS, "cpanel.lisc file is missing" );
        return;
    }
    print_working("Checking permissions on cpanel.lisc file: ")
      unless ( !$verbose );
    my $statmode = qx[ stat -c "%a" $cPLiscFile ];
    chomp($statmode);
    if ( $statmode != 644 ) {
        push(
            @WARNINGS,
            "Invalid permissions on /usr/local/cpanel/cpanel.lisc [" . $statmode . "] - Should be 644"
        );
    }
    else {
        print BOLD GREEN "\t\\_ OK!\n" unless ( !$verbose );
    }
    my $age;
    $age = ( stat("$cPLiscFile") )[9];
    my $TimeDiff = $timenow - $age;
    if ( $TimeDiff > 604800 ) {
        push( @WARNINGS, "$cPLiscFile file is older than 7 days!" );
    }
    my $attr = `/usr/bin/lsattr $cPLiscFile`;
    if ( $attr =~ m/^\s*\S*[ai]/ ) {
        $sendtomsg = CYAN "Please send to L3";
        $L3=1;
        push( @WARNINGS, "$cPLiscFile is immutable - " . $sendtomsg ) unless ( !iam('cptech') );
    }
    print_working("Checking if cpanel.lisc can be locked: ")
      unless ( !$verbose );
    my $Lockable = qx[ /usr/bin/flock -w 5 $cPLiscFile -c "echo 1" || echo "0" ];
    chomp($Lockable);
    if ($Lockable) {
        print BOLD GREEN "\t\\_ Yes\n" unless ( !$verbose );
    }
    else {
        print RED "\t\\_ No\n" unless ( !$verbose );
        $sendtomsg = CYAN "Please send to L3";
        $L3=1;
        push(
            @WARNINGS,
            "Could not obtain lock on $cPLiscFile - " . $sendtomsg
        ) unless ( !iam('cptech') );
    }
}

sub run_rdate {
    return if ( $envtype eq "virtuozzo" );
    return if ( $envtype eq "vzcontainer" );
    print_working("Checking if rdate completes without error:")
      unless ( !$verbose );
    my $rdatesuccess = qx[ rdate -s rdate.cpanel.net 2>&1 ];
    if ($rdatesuccess) {
        print RED "\t\\_ Error - $rdatesuccess\n" unless ( !$verbose );
        push( @WARNINGS, "rdate command failed! [$rdatesuccess]" );
    }
    else {
        print BOLD GREEN "\t\\_ Yes\n" unless ( !$verbose );
    }
}

sub chkCreds {
    return if ( -e ("/var/cpanel/licenseid_credentials.json") );
    push(
        @WARNINGS,
        "licenseid_credentials.json file missing - is port 2083 inbound open?"
    );
}

sub display_route {
    return if ( !$verbose );
    print_working("Displaying route -n:");
    print BOLD YELLOW "\t \\ \n";
    system_formatted("route -n");
    print_working("Displaying ip route:");
    print BOLD YELLOW "\t \\ \n";
    system_formatted("ip route");
    print_working("Displaying ip addr show:");
    print BOLD YELLOW "\t \\ \n";
    system_formatted("ip addr show");
}

sub get_cpsrvd_restarts {
    return if ( !$verbose );
    print_working("Displaying last 20 cpsrvd restarts:");
    my $cpsrvdrestline;
    my @CPSRVD_RESTARTS = qx[ grep 'Restarting cpsrvd daemon process' /usr/local/cpanel/logs/error_log | tail -20 ];
    foreach $cpsrvdrestline (@CPSRVD_RESTARTS) {
        chomp($cpsrvdrestline);
        $cpsrvdrestline =~ s/\.//g;
        my ( $restartdate, $restarttime, $restartdst ) =
          ( split( /\s+/, $cpsrvdrestline ) )[ 0, 1, 2 ];
        print YELLOW "\t \\_ " . $restartdate . " " . $restarttime . " " . $restartdst . "\n";
    }
    print_working("Checking /root/.bash_history for restarts:");
    my $histline;
    foreach $histline (@HISTORY) {
        chomp($histline);
        if (   $histline =~ m/cpanel.service/
            or $histline =~ m/scripts\/restartsrv_cpsrvd/
            or $histline =~ m/service cpanel restart/
            or $histline =~ m/etc\/init.d\/cpanel/ ) {
            print YELLOW "\t \\_ Found: " . BOLD GREEN $histline . "\n"
              unless ( $histline =~ m/grep/ );
        }
        if ( $histline =~ m/cgls/ ) {
            $sendtomsg = CYAN "Please send to L3";
            $L3=1;
            push( @WARNINGS, $sendtomsg . " [CPANEL-22182]" ) unless ( !iam('cptech') or $cgls );
            $cgls = 1;
        }
    }
}

sub get_last_reboots {
    return if ( !$verbose );
    print_working("Getting Last 20 reboots:");
    my @LastReboots = qx[ last | grep reboot ];
    my $cnt         = 0;
    my ( $rebootline, $kernel, $mday, $mon, $day, $hhmm );
    foreach $rebootline (@LastReboots) {
        chomp($rebootline);
        ( $kernel, $mday, $mon, $day, $hhmm ) =
          ( split( /\s+/, $rebootline ) )[ 3, 4, 5, 6, 7 ];
        print YELLOW "\t \\_ Reboot detected with kernel $kernel On: $mday $mon $day $hhmm\n";
        $cnt++;
        if ( $cnt >= 20 ) { last; }
    }
}

sub getVerifyDATA {
    return if ( !$verbose );
    print_working("https://verify.cpanel.net data for $external_ip_address");
    my $regex          = qr{'([^']+)', '([^']+)', '([^']+)', '([^']+)', '([^']+)', '([^']+)'};
    my @DATAVerifyPage = qx[ curl -s "https://verify.cpanel.net/app/verify?ip=$external_ip_address&nohtml=1" | grep 'active' ];
    my $DataVerifyLine;
    foreach $DataVerifyLine (@DATAVerifyPage) {
        $DataVerifyLine =~ s/$regex/\t \\_ License ID: $1\n\t \\_ IP Address: $2\n\t \\_ License Type: $3\n\t \\_ Partner: $4\n\t \\_ Active Since $5\n\t \\_ Status: $6\n/;
        print BOLD GREEN "$DataVerifyLine";
    }
}

sub getVerifyJSON {
    print_working("https://verify.cpanel.net JSON data for $external_ip_address \n");
    my $JSONVerifyPage = qx[ curl -s "https://verify.cpanel.net/api/verifyfeed?json=1&ip=$external_ip_address" ];
    print CYAN $JSONVerifyPage;
}

sub Usage {
    print WHITE "cplicensets [no options is default] displays basic info and any warnings found\n";
    print WHITE "cplicensets --verbose displays all info\n";
    print WHITE "cplicensets --verifypage displays https://verify.cpanel.net in JSON output and exits\n";
    print WHITE "cplicensets --withlogs displays last 50 lines of license_log file\n";
    print WHITE "cplicensets --skipdate skips date check which can sometimes fail\n";
    print WHITE "cplicensets --help You're looking at it!\n";
    print "</c>\n";
    exit;
}

sub read_last_50_lines_of_license_log {
    print_working("Displaying last 50 lines of /usr/local/cpanel/logs/license_log:");
    my $lineswanted = 50;
    my $filename    = "/usr/local/cpanel/logs/license_log";
    my ( $line, $filesize, $seekpos, $numread, @lines );
    open F, $filename or die "Can't read $filename: $!\n";
    $filesize = -s $filename;
    $seekpos  = 50 * $lineswanted;
    $numread  = 0;
    while ( $numread < $lineswanted ) {
        @lines   = ();
        $numread = 0;
        seek( F, $filesize - $seekpos, 0 );
        <F> if $seekpos < $filesize;
        while ( defined( $line = <F> ) ) {
            push @lines, $line;
            shift @lines if ++$numread > $lineswanted;
        }
        if ( $numread < $lineswanted ) {
            if ( $seekpos >= $filesize ) {
                die "There aren't even $lineswanted lines in $filename - I got $numread\n";
            }
            $seekpos *= 2;
            $seekpos = $filesize if $seekpos >= $filesize;
        }
    }
    close F;
    print CYAN @lines;
}

sub get_date {
    return if ($skipdate);
    print_working("Checking Date/Time:") unless ( !$verbose );
    my ($servertime) = ( split( /\./, clock_gettime(CLOCK_REALTIME) ) );
    print BOLD GREEN ON_BLACK "\t \\_ Server Time: " . $servertime . " (" . scalar localtime($servertime) . ")\n"
      unless ( !$verbose );
    my ($utctime) = (
        split(
            /\./,
            qx[ /usr/bin/curl -s https://cpaneltech.ninja/cgi-bin/date.pl ]
        )
    );
    if ( $utctime eq "" ) {
        ($utctime) = (
            split(
                /\./,
                qx[ /usr/bin/curl -sk https://cpaneltech.ninja/cgi-bin/date.pl ]
            )
        );
    }
    if ( $utctime eq "" ) {
        $utctime = "Could Not Retrieve! - check network/firewall\n";
        push(
            @WARNINGS,
            "Could not retrieve Outside Location time - check network/firewall"
        );
    }
    else {
        print BOLD GREEN ON_BLACK "\t \\_ Outside Location: " . $utctime . " (" . scalar localtime($utctime) . ")\n"
          unless ( !$verbose );
        my $timediff = $servertime - $utctime;
        if ( $timediff != 0 ) {
            if ( $timediff < -5 or $timediff > 5 ) {
                print_warn("\t \\_ [WARN] - Date/Time is off by more than 5 seconds!\n") unless ( !$verbose );
                push( @WARNINGS, "Date/Time is off by more than 5 seconds!" );
            }
            else {
                print_OK("\t \\_ [OK] - Date/Time is within 5 seconds!\n")
                  unless ( !$verbose );
            }
        }
    }
}

sub check_for_solo {
    my $isSolo = CYAN "No";
    if ( $isSoloNum == 1 ) {
        $isSolo = CYAN "Yes";
    }
    print_working("Is this a SOLO license: $isSolo");
    my $userowners = Cpanel::Config::LoadUserOwners::loadtrueuserowners( undef, 1, 1 );
    my $TotalAccts = %{$userowners};
    if ( $TotalAccts > 1 and $isSoloNum == 1 ) {
        my $CSA = CSA();
        if ($CSA) {
			if ($L3) { 
            	$sendtomsg = CYAN "Please send to L3"; 
			}
			else { 
            	$sendtomsg = CYAN "Please send to Customer Service"; 
			}
            push(
                @WARNINGS,
                "SOLO license with more than 1 account - " . $sendtomsg
            ) unless ( !iam('cptech') );
        }
        else {
            $sendtomsg = CYAN "Please send to L3";
            push(
                @WARNINGS,
                "SOLO license with more than 1 account - " . $sendtomsg
            ) unless ( !iam('cptech') );
        }
    }
}

sub check_for_GCE {
    $isGCE_IP = getGCE_IPs($external_ip_address);
    my $isGCE = ($isGCE_IP) ? "Yes" : "No";
    print BOLD YELLOW "Running on Google Compute Engine (GCE): " . CYAN $isGCE . "\n";

    if ($isGCE eq "Yes") { 
        # What does Google say the hostname is set to?
        my $GCEHostname = qx[ curl --silent "http://metadata.google.internal/computeMetadata/v1/instance/attributes/hostname" -H "Metadata-Flavor: Google" ];
        chomp($GCEHostname);
        if ($GCEHostname =~ m/Error|404|DOCTYPE/) { 
            return;
        }
        else { 
            if ($GCEHostname) {
                if ( $GCEHostname ne $HOSTNAME ) {
                    push( @WARNINGS, "Google set the hostname to: $GCEHostname which does not match $HOSTNAME" );
                }
            }
        }
    }
}

sub check_for_AWS {
    $isAWS_IP = getAWS_IPs($external_ip_address);
    my $isAWS = ($isAWS_IP) ? "Yes" : "No";
    print BOLD YELLOW "Running on Amazon Web Services (AWS): " . CYAN $isAWS . "\n";
}

sub _init_run_state {
    return if defined $RUN_STATE;
    $RUN_STATE = {
        STATE => 0,
        type  => {
            cpanel  => 1 << 0,
            solo    => 1 << 1,
            dnsonly => 1 << 2,
            cptech  => 1 << 3,
        },
    };
    return 1;
}

sub _set_run_type {
    my ($type) = @_;
    print STDERR "Runtime type ${type} doesn't exist\n" and return unless exists $RUN_STATE->{type}->{$type};
    return $RUN_STATE->{STATE} |= $RUN_STATE->{type}->{$type};
}

sub iam {
    my $want = 0;
    grep { return 0 unless exists $RUN_STATE->{type}->{$_}; $want |= $RUN_STATE->{type}->{$_} } @_;
    return $want == ( $want & $RUN_STATE->{STATE} );
}

sub CSA {
    my $dt    = DateTime->now( time_zone => 'America/Chicago' );
    my $DAY   = $dt->strftime("%a");
    my $HOUR  = $dt->hour;
    my $STIME = 6;
    my $QTIME;
    if ( $DAY eq "Sat" or $DAY eq "Sun" ) {
        $QTIME = 16;
    }
    else {
        $QTIME = 18;
    }
    if ( $HOUR >= $STIME and $HOUR < $QTIME ) {
        return 1;
    }
    else {
        return 0;
    }
}

sub proxy_chk {
    my $is_listening = qx[ netstat -nap | grep 'LISTEN' | grep '43467' ];
    if ($is_listening) {
        $sendtomsg = CYAN "Please send to L3";
        $L3=1;
        push( @WARNINGS, "Possible proxy found on port 43467 - " . $sendtomsg ) unless ( !iam('cptech') );
    }
    return if (! -e "/usr/bin/traceroute");
    my $troute = qx[ traceroute -T -p 2089 auth.cpanel.net | grep -v 'traceroute to' | wc -l ];
	# RIGHT HERE
    if ( $troute < 3 ) {
        $L3=1;
        $sendtomsg = CYAN "Please send to L3";
        push( @WARNINGS, "Possible proxy found - " . $sendtomsg ) unless ( !iam('cptech') );
    }
}

sub chk_for_cloud_ready {
    return if ( -e "/usr/local/cpanel/.cloud-ready" );
    my $local_error = qx[ grep 'rc.local' /var/log/messages | grep 'Unknown error' | tail -1 ];
    if ($local_error) {
        push(
            @WARNINGS,
            ".cloud-ready touchfile not found under /usr/local/cpanel. Is hostname reverting? [NO-1573]"
        );
    }
}
